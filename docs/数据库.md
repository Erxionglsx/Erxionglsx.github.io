# 数据库

------

[TOC]

### 关系型数据库和非关系型数据库

**DML：数据操作语言**

insert,delete,update,select,add

**DDL：数据定义语言**

alert,create,table,drop,create,database,drop,database

**关系型数据库：**

mysql,sql-server,oracle,db2,sybase,informix,access

**非关系型数据库：**

mongoDB,redis,hbase,memcache

**区别：**

* 存储的数据类型不同
* 数据表的结构不同
* 数据容量不同
* 数据访问效率不同

|              数据库类型              |                             特性                             |                             优点                             |                             缺点                             |
| :----------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  关系型数据库 SQLite、Oracle、mysql  | 1、关系型数据库，是指采用了关系模型来组织 数据的数据库； 2、关系型数据库的最大特点就是事务的一致性； 3、简单来说，关系模型指的就是二维表格模型， 而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。 | 1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解； 2、使用方便：通用的SQL语言使得操作关系型数据库非常方便； 3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率； 4、支持SQL，可用于复杂的查询。 | 1、为了维护一致性所付出的巨大代价就是其读写性能比较差； 2、固定的表结构； 3、高并发读写需求； 4、海量数据的高效率读写； |
| 非关系型数据库 MongoDb、redis、HBase | 1、使用键值对存储数据； 2、分布式； 3、一般不支持ACID特性； 4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。 | 1、无需经过sql层的解析，读写性能很高； 2、基于键值对，数据没有耦合性，容易扩展； 3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。 | 1、不提供sql支持，学习和使用成本较高； 2、无事务处理，附加功能bi和报表等支持也不好； |

### SQL语句

<font color="lighblue">创建表</font>

* PRIMARY KEY 约束唯一标识数据库表中的每条记录。
* 主键必须包含唯一的值。
* 主键列不能包含 NULL 值。
* 每个表都应该有一个主键，并且每个表只能有一个主键。

```sql
create table student
(
         s_id int(4) not null PRIMARY KEY auto_increment,
		s_name varchar(12),
		s_age int(4),
		s_sex varchar(2),
		s_date date,
         FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
);
```

<font color="lighblue">INSERT INTO</font> 语句用于向表格中<font color="lighblue">插入新的行</font>。

```sql
insert into Persons values ('Wilson', 'Champs-Elysees');
INSERT INTO Persons (LastName, Address) VALUES ('Wilson', 'Champs-Elysees');
```

<font color="lighblue">Update</font> 语句用于<font color="lighblue">修改</font>表中的数据。

```sql
UPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing' WHERE LastName = 'Wilson';
```

<font color="lighblue">DELETE</font> 语句用于<font color="lighblue">删除</font>表中的行。

```sql
DELETE FROM Person WHERE LastName = 'Wilson' ;
```

<font color="lighblue">查询</font>语句

```sql
select * from student s,score c;
select s2.s_name,count(*) as num from score s1 INNER JOIN student s2 on s1.s_no = s2.s_id GROUP BY s2.s_name;--分组查询
```

<font color="lighblue">ORDER BY</font> 语句用于对结果集进行<font color="lighblue">排序</font>。

```sql
SELECT Company, OrderNumber FROM Orders ORDER BY OrderNumber --顺序显示，小->大
SELECT Company, OrderNumber FROM Orders ORDER BY OrderNumber DESC --逆序显示，大->小
```

<font color="lighblue">LIKE 操作符</font>用于在 WHERE 子句中搜索列中的指定模式。

SQL通配符必须与LIKE运算符一起使用：

|           通配符           |            描述            |
| :------------------------: | :------------------------: |
|             %              |     替代一个或多个字符     |
|             _              |       仅替代一个字符       |
|         [charlist]         |   字符列中的任何单一字符   |
| [^charlist]或者[!charlist] | 不在字符列中的任何单一字符 |

```sql
-- "Persons" 表中选取居住在以 "N" 开始的城市里的人
SELECT * FROM Persons WHERE City LIKE 'N%';
-- 从 "Persons" 表中选取居住在不包含 "lon" 的城市里的人
SELECT * FROM Persons WHERE City NOT LIKE '%lon%';
-- "Persons" 表中选取名字的第一个字符之后是 "eorge" 的人
SELECT * FROM Persons WHERE FirstName LIKE '_eorge';
--"Persons" 表中选取居住的城市以 "A" 或 "L" 或 "N" 开头的人
SELECT * FROM Persons WHERE City LIKE '[ALN]%';
--"Persons" 表中选取居住的城市不以 "A" 或 "L" 或 "N" 开头的人
SELECT * FROM Persons WHERE City LIKE '[!ALN]%';

--在Mybatis中使用模糊查询
SELECT * FROM Persons WHERE goodsName like concat('%',#{goodsName},'%');
```

<font color="lighblue">IN 操作符</font>允许我们在 WHERE 子句中<font color="lighblue">规定多个值</font>。

```sql
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...)
```

<font color="lighblue">SQL UNIQUE 约束</font>

* UNIQUE 约束唯一标识数据库表中的每条记录。
* UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
* PRIMARY KEY 拥有自动定义的 UNIQUE 约束。

每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。

操作符 <font color="lighblue">BETWEEN ... AND</font> 会选取介于两个值之间的<font color="lighblue">数据范围</font>。这些值可以是数值、文本或者日期。(不同的数据库对 BETWEEN...AND 操作符的处理方式是有差异的。)

```sql
SELECT column_name(s)
FROM table_name
WHERE column_name
BETWEEN value1 AND value2
```

通过使用 SQL，可以为列名称和表名称<font color="lighblue">指定别名</font>（AS）。

```sql
SELECT column_name AS name FROM table_name
SELECT LastName AS Family, FirstName AS Name FROM Persons
```

<font color="lighblue">SQL join</font> 用于根据<font color="lighblue">两个或多个表</font>中的列之间的关系，从这些表中查询数据。

- <font color="lighblue">JOIN</font>: 如果表中有至少一个匹配，则返回行，INNER JOIN 与 JOIN 是相同的。
- <font color="lighblue">LEFT JOIN</font>: 即使右表中没有匹配，也从左表返回所有的行
- <font color="lighblue">RIGHT JOIN</font>: 即使左表中没有匹配，也从右表返回所有的行
- <font color="lighblue">FULL JOIN</font>: 只要其中一个表中存在匹配，就返回行

```sql
select * from student s,score c where s.s_id = c.c_id;
select * from student s INNER JOIN score c on s.s_id = c.s_no; -- 内连接
select * from student s LEFT JOIN score c on s.s_id = c.s_no; -- 左连接
select * from student s RIGHT JOIN score c on s.s_id = c.s_no; -- 右连接
select * from student s FULL JOIN score c on s.s_id = c.s_no;
```

<font color="lighblue">CREATE INDEX</font> 语句用于在表中<font color="lighblue">创建索引</font>。

在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。

```sql
CREATE INDEX PersonIndex ON Person (LastName);
CREATE INDEX PersonIndex ON Person (LastName, FirstName);--列出两列索引
```

可以使用 <font color="lighblue">DROP INDEX </font>命令<font color="lighblue">删除表格中的索引</font>。

```sql
ALTER TABLE table_name DROP INDEX index_name; --MySQL
```

<font color="lighblue">DROP DATABASE</font> 语句用于<font color="lighblue">删除数据库</font>：

```sql
DROP DATABASE 数据库名称; --删除数据库：
DROP TABLE 表名称; --删除表（表的结构、属性以及索引也会被删除）
TRUNCATE TABLE 表名称; --除去表内的数据，但并不删除表本身
```

<font color="lighblue">ALTER TABLE</font> 语句用于在已有的表中<font color="lighblue">添加、修改或删除列</font>。

```sql
ALTER TABLE table_name ADD column_name datatype;--添加列
ALTER TABLE table_name DROP COLUMN column_name;--删除列
```

在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。

```sql
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
```

MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：

- DATE - 格式 YYYY-MM-DD
- DATETIME - 格式: YYYY-MM-DD HH:MM:SS
- TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS
- YEAR - 格式 YYYY 或 YY

### SQL函数

<font color="lighblue">AVG()</font> 函数返回数值列的<font color="lighblue">平均值</font>。NULL 值不包括在计算中。

```sql
SELECT AVG(column_name) FROM table_name;
SELECT AVG(OrderPrice) AS OrderAverage FROM Orders;--计算 "OrderPrice" 字段的平均值。
SELECT Customer FROM Orders WHERE OrderPrice > (SELECT AVG(OrderPrice) FROM Orders);--找到 OrderPrice 值高于 OrderPrice 平均值的客户。
```

<font color="lighblue">COUNT()</font> 函数返回匹配指定条件的<font color="lighblue">行数</font>。

```sql
SELECT COUNT(column_name) FROM table_name;--COUNT(column_name) 函数返回指定列的值的数目。
SELECT COUNT(Customer) AS CustomerNilsen FROM Orders WHERE Customer='Carter';--计算客户 "Carter" 的订单数。
```

<font color="lighblue">FIRST() </font>函数返回指定的字段中<font color="lighblue">第一个记录的值</font>。

```sql
SELECT FIRST(column_name) FROM table_name;
SELECT FIRST(OrderPrice) AS FirstOrderPrice FROM Orders;--查找 "OrderPrice" 列的第一个值。
```

<font color="lighblue">LAST() </font>函数返回指定的字段中<font color="lighblue">最后一个记录的值</font>。

```sql
SELECT LAST(column_name) FROM table_name;
SELECT LAST(OrderPrice) AS LastOrderPrice FROM Orders;--查找 "OrderPrice" 列的最后一个值
```

<font color="lighblue">MAX() </font>函数返回指定列的<font color="lighblue">最大值</font>。

```sql
SELECT MAX(column_name) FROM table_name;
SELECT MAX(alexa) AS max_alexa FROM Websites;--从 "Websites" 表的 "alexa" 列获取最大值
```

<font color="lighblue">MIN() </font>函数返回指定列的<font color="lighblue">最小值</font>。

```sql
SELECT MIN(column_name) FROM table_name;
SELECT MIN(alexa) AS min_alexa FROM Websites;--从 "Websites" 表的 "alexa" 列获取最小值
```

<font color="lighblue">SUM() </font>函数返回数值<font color="lighblue">列的总数</font>。

```sql
SELECT SUM(column_name) FROM table_name;
SELECT SUM(count) AS nums FROM access_log;--查找 "access_log" 表的 "count" 字段的总数
```

<font color="lighblue">GROUP BY</font> 语句可结合一些聚合函数来使用,根据一个或多个列对结果集进行<font color="lighblue">分组</font>:

```sql
SELECT site_id, SUM(access_log.count) AS nums FROM access_log GROUP BY site_id;--统计 access_log 各个 site_id 的访问量
```

WHERE 关键字无法与聚合函数一起使用,<font color="lighblue">HAVING </font>子句可以让我们筛选分组后的各组数据。

```sql
SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log
INNER JOIN Websites
ON access_log.site_id=Websites.id)
GROUP BY Websites.name
HAVING SUM(access_log.count) > 200;
--查找总访问量大于 200 的网站
```

<font color="lighblue">LEN</font> 函数返回文本<font color="lighblue">字段中值的长度</font>。

```sql
SELECT LEN(column_name) FROM table_name;
SELECT LEN(City) as LengthOfCity FROM Persons;--取得 "City" 列中值的长度
```

<font color="lighblue">Replace()</font>函数替换某个字段中某段字符串。

```sql
--在字符串 store_id 中所有出现的字符串 179e58f58d9543 均被 155666666替换，然后返回这个字符串：
UPDATE `tata_users` set store_id = REPLACE(store_id,'179e58f58d9543','155666666');
```

<font color="lighblue">find_in_set()</font>函数查询以逗号分割的字符串中的某一字符串。

```sql
--CITY_CODE:2145,233,6888
--CITY_CODE:2345,23343,684233
select CITY_CODE from user where FIND_IN_SET('233',CITY_CODE); 
--查询结果:CITY_CODE:2145,233,6888
```

<font color="lighblue">case when</font>函数，改变查询结果

```sql
CASE WHEN sex = '1' THEN '男'
         WHEN sex = '2' THEN '女'
ELSE '其他' END   
```

在when后面可以跟多个表达式

```sql
CASE WHEN sex = '1' and name ='Java3y' THEN '男'
         WHEN sex = '2' and name ='Java4y' THEN '女'
ELSE '其他' END 
```

复习SQL语句：

```sql
CREATE TABLE Student 
(
     id INT(4) NOT NULL PRIMARY KEY auto_increment,
	 name VARCHAR(50) NOT NULL,
	 sex VARCHAR(50) NOT NULL,
	 age INT(4) NOT NULL,
	 grade INT(5) NOT NULL,
	 birthday DATE
);

INSERT INTO student(name,sex,age,grade,birthday) VALUES ("王五","男",22,84,"1997-01-01");
INSERT INTO student(name,sex,age,grade,birthday) VALUES ("张三","男",24,54,"1997-05-21");

UPDATE student SET name="李四",sex="女" where id=2;

SELECT * from student where age=22;

DELETE from student where id=2;

ALTER TABLE student ADD phone VARCHAR(10);

ALTER TABLE student ALTER sex VARCHAR(55);

-- 添加索引
CREATE UNIQUE INDEX Sid ON student(id);
CREATE INDEX Sgrade ON student(grade DESC,age); 

-- 删除索引
ALTER TABLE student DROP INDEX id;

-- 用as起别名
select Sno,Sname,2020-Sage as Date,Sdept from student;
-- 消除取消重复的行
select DISTINCT Ssex FROM student;
-- 使用where子句
select * from student where Sdept = '软件学院';
-- 使用between子句
select * from student where Sage between 20 and 22;
select * from student where Sage not between 20 and 22;
-- 使用in字句
select Sno,Sname,Sage from student where Sdept in ('软件学院','马克思学院');
select Sno,Sname,Sage from student where Sdept not in ('软件学院','马克思学院');
-- 模糊查询
select * from student where Sname like '张%';
select * from student where Sname like '李_';
select * from student where Sname like '%三%';
-- 排序
select * from sc order by Grade;
select * from sc order by Grade DESC;
select * from sc order by Cno,Grade DESC;
-- 聚集函数
select Sno,avg(grade) as 平均分 from sc where Sno="171303";
select count(distinct Sno) as 选修学生总数 from sc; 
select max(Grade) as 最高分,min(Grade)as 最低分 from sc;
select sum(Grade) as 总分 from sc;
-- 分组查询
select Sdept,count(*) as 人数 from student group by Sdept;
select Sno,avg(Grade) as 均分 from sc group by Sno having avg(Grade)>60;
-- 等值与非等值查询
select student.*,sc.Grade,sc.Cno from student,sc where student.Sno=sc.Sno;
-- 自身连接查询
select a.Sno,a.Cno,b.Grade from sc a, sc b where a.Grade=b.Grade and a.Cno!=b.Cno;
-- 外连接查询
select student.*,sc.Cno,sc.Grade from student left join sc on student.Sno=sc.Sno;
select student.*,sc.Cno,sc.Grade from student right join sc on student.Sno=sc.Sno;
-- 嵌套查询
select * from student where Sno in (select Sno from sc where Cno="001");
-- 视图
create view J_Student as select student.*,sc.Grade,sc.Cno from student,sc where student.Sno=sc.Sno;
select * from J_Student where Grade>70;
update J_Student set Sage=24 where Grade=78;
drop view J_Student;
```

![1600250814201](C:\Users\22874\AppData\Roaming\Typora\typora-user-images\1600250814201.png)

#### 按12个月统计,没有的月份补齐

```sql
select a.date,ifnull(b.num,0) as num from 
(SELECT CONCAT(#{year},'-01') AS date UNION
SELECT CONCAT(#{year},'-02') AS date UNION
SELECT CONCAT(#{year},'-03') AS date UNION
SELECT CONCAT(#{year},'-04') AS date UNION
SELECT CONCAT(#{year},'-05') AS date UNION
SELECT CONCAT(#{year},'-06') AS date UNION
SELECT CONCAT(#{year},'-07') AS date UNION
SELECT CONCAT(#{year},'-08') AS date UNION
SELECT CONCAT(#{year},'-09') AS date UNION
SELECT CONCAT(#{year},'-10') AS date UNION
SELECT CONCAT(#{year},'-11') AS date UNION
SELECT CONCAT(#{year},'-12') AS date
)a
left join
(select count(store_name) num,DATE_FORMAT(create_dt,'%Y-%m') as date from t_ord_cfm_repair where repair_state >=1200 and del_fg=0 GROUP BY date) b 
on a.date = b.date order by date;
-- DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据。
-- CONCAT() 返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。
-- IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。
```

![](https://note.youdao.com/yws/api/personal/file/53A206E219B74DECB554A9D8588FF6DC?method=download&shareKey=ca7da52e9589a4994bb5ef9bfc850ca3)

#### SQL语句中1=1的作用

**1=1的用处** 

where 1=1 是为了避免where 关键字后面的第一个词直接就是 “and”而导致语法错误。

动态SQL中连接AND条件

where 1=1 是为了避免where 关键字后面的第一个词直接就是 “and”而导致语法错误。

因为table中根本就没有名称为1的字段，所以该SQL等效于select * from table，

这个SQL语句很明显是全表扫描，需要大量的IO操作，数据量越大越慢，建议查询时增加必输项，即where 1=1后面追加一些常用的必选条件，并且将这些必选条件建立适当的索引，效率会大大提高。

where后面总要有语句，加上了1=1后就可以保证语法不会出错!

可以避免如果不需要where条件时，你还要判断需不需要写where关键字

#### UNION和UNION ALL的区别

UNION和UNION ALL的区别是,UNION会自动压缩多个结果集合中的重复结果，而UNION ALL则将所有的结果全部显示出来，不管是不是重复。
**Union**：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；
UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。
实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION

**Union All**：对两个结果集进行并集操作，包括重复行，不进行排序；
如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。

### mysql有哪些数据类型

1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、 BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。 

2、实数类型，包括FLOAT、DOUBLE、DECIMAL。 

DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。 

而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL可以理解成是用字符串进行处理。 

3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB 

VARCHAR用于存储可变长字符串，它比定长类型更节省空间。 

VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。 

VARCHAR存储的内容超出设置的长度时，内容会被截断。 

CHAR是定长的，根据定义的字符串长度分配足够的空间。 

CHAR会根据需要使用空格进行填充方便比较。 

CHAR适合存储很短的字符串，或者所有值都接近同一个长度。 

CHAR存储的内容超出设置的长度时，内容同样会被截断。 

**使用策略：** 

对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。

对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。 

使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。 

4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。 

ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。 

ENUM在内部存储时，其实存的是整数。 

尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。 

5、日期和时间类型，尽量使用timestamp，空间效率高于datetime用整数保存时间戳通常不方便处理。

### SQL调优

1. 在经常需要进行检索的字段上创建索引
2. 一个表的索引数最好不要超过6个，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引
3. 尽量将多条SQL语句压缩到一句SQL中，避免过多的执行SQL语句
4. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段
5. 尽可能的使用 varchar/nvarchar 代替 char/nchar，可变长字段存储空间小，可以节省存储空间，搜索效率更高
6. 除聚合函数用到HAVING外，其他地方尽量用where字句替换HAVING字句
7. 尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
8. in 和 not in 也要慎用，否则会导致全表扫描

### 索引

> https://www.cnblogs.com/fengqiang626/archive/2019/09/04/11459434.html

数据库索引就是为了提高表的搜索效率而对某些字段中的值建立的目录 ，索引的数据结构用到了**B+树**。

**目的**：加快检索表中数据

数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为**聚簇索引**和**非聚簇索引**两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。

**唯一索引**：唯一索引是不允许其中任何两行具有相同索引值的索引。数据列不允许重复，允许为NULL值，<font color="lighblue">一个表可以有多个唯一索引</font>。

**主键索引**：数据库表经常有一列或多列组合，其值唯一标识表中的每一行。数据列不允许重复，不允许为NULL，一个表只能有一个主键。

**聚集索引**：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。<font color="lighblue">一个表只能包含一个聚集索引</font>。

**优点**：

* 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
* 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
* 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
* 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
* 第五，通过使用[索引](https://baike.baidu.com/item/索引)，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点**：

* 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
* 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
* 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### MySQL索引类型

normal：表示普通索引

unique：表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique

full textl: 表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。

spatial

#### 索引七大原则

1．选择唯一性索引
2．为经常需要排序、分组和联合操作的字段建立索引
3．为常作为查询条件的字段建立索引，适合索引的列是出现在where子句中的列，或者连接子句中指定的列 
4．限制索引的数目
5．使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间 
6．尽量使用前缀来索引
7．删除不再使用或者很少使用的索引
8．不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可

#### 创建索引的原则

* 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 
* 较频繁作为查询条件的字段才去创建索引 
* 更新频繁字段不适合创建索引 
* 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低) 
* 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 
* 定义有外键的数据列一定要建立索引。 
* 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。 
* 对于定义为text、image和bit的数据类型的列不要建立索引。 

**索引可以是单列索引，也可以是多列索引**

（1）单列索引就是常用的一个列字段的索引，常见的索引。 
（2）多列索引就是含有多个列字段的索引 

**注意**：多列索引只有在where条件中含有索引中的首列字段时才有效 

#### b+树性质

**1.索引字段要尽量的小**：IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数。所以我们需要将树建的越低越好，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，因为id是个数字，占用空间最少啊。

**2.索引的最左匹配特性**：简单来说就是你的数据来了以后，从数据块的左边开始匹配，再匹配右边的。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了，这个是非常重要的性质，即索引的最左匹配特性。

索引是有个最左匹配的原则的，所以建联合索引的时候，将**区分度高的放在最左边**，依次排下来，范围查询的条件尽可能的往后边放。在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 

**注意**：

- 避免使用select *
- count(1)或count(列) 代替 count(*)
- 创建表时尽量用 char 代替 varchar
- 表的字段顺序固定长度的字段优先
- 组合索引代替多个单列索引（经常使用多个条件查询时）
- 尽量使用短索引
- 使用连接（JOIN）来代替子查询(Sub-Queries)
- 连表时注意条件类型需一致
- 索引散列值（重复少）不适合建索引，例：性别不适合

### 三范式

> https://www.cnblogs.com/xiaozengzeng/p/10720226.html

1NF:字段不可分;

2NF:有主键，非主键字段依赖主键;

3NF:非主键字段不能相互依赖;

**解释:**

1NF:原子性 字段不可再分,否则就不是关系数据库;

2NF:唯一性 一个表只说明一个事物;

3NF:每列都与主键有直接关系，不存在传递依赖;

### 脏读、幻读、不可重复读

**脏读:**举个例子,如果你正在读数据库内容,而我现在修改了数据库内容还没有提交,接着我修改后的内容没有提交的情况下被你读到了,就叫脏读。

**幻读**:举个例子,比如你正在读数据库内容,而我insert数据库后提交了,你又读了一次数据库内容,这时你看到内容出现了多一条数据,这叫幻读。

**不可重复读:**举个例子,比如你正在读数据库内容,而我update数据库后提交了,你又读了一次数据库内容,这时出现两个内容不同的结果,这叫不可重复读。

一般来说，锁可以防止脏读、不可重复读和幻觉读。

 事务隔离五种级别：
        TRANSACTION_NONE  不使用事务。
        TRANSACTION_READ_UNCOMMITTED  允许脏读。
        TRANSACTION_READ_COMMITTED  防止脏读，最常用的隔离级别,并且是大多数数据库的默认隔离级别
        TRANSACTION_REPEATABLE_READ  可以防止脏读和不可重复读，
        TRANSACTION_SERIALIZABLE  可以防止脏读，不可重复读取和幻读，（事务串行化）会降低数据库的效率

* 脏读：修改时加排他锁，直到事务提交后才释放，读取时加共享锁，读取完释放事务1读取数据时加上共享锁后（这 样在事务1读取数据的过程中，其他事务就不会修改该数据），不允许任何事物操作该数据，只能读取，之后1如果有更新操作，那么会转换为排他锁，其他事务更 无权参与进来读写，这样就防止了脏读问题。
  但是当事务1读取数据过程中，有可能其他事务也读取了该数据，读取完毕后共享锁释放，此时事务1修改数据，修改 完毕提交事务，其他事务再次读取数据时候发现数据不一致，就会出现不可重复读问题，所以这样不能够避免不可重复读问题。
* 不可重复读：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题
* 幻读问题：采用的是范围锁RangeS RangeS_S模式，锁定检索范围为只读，这样就避免了幻影读问题，在这里有个描述范围锁的文章。

### 锁表

解决死锁的方案

第一种：

1.查询是否锁表

```sql
show OPEN TABLES where In_use > 0;
```

2.查询进程(如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程)

```sql
show processlist
```

3.杀死进程id(就是上面命令的id列)

kill id

第二种：

1.查看下在锁的事务

```sql
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```

2.杀死进程id(就是上面命令的trx_mysql_thread_id列)

kill 线程ID








