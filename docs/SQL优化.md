# SQL优化

[TOC]

### MySql优化

1.  在经常需要进行检索的字段上创建索引。

2.  一个表的索引数最好不要超过6个，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。

3.  尽量将多条SQL语句压缩到一句SQL中，避免过多的执行SQL语句。

4.  索引字段的选择, 最佳候选列应当从 where 子句的条件中提取, 如果 where 子句中的组合比较多, 那么应当挑选最常用。

5.  尽量避免使用 select \* from user ，用具体的字段列表代替“\*”，不要返回用不到的任何字段。从数据库里读出越多的数据，那么查询就会变得越慢。

6.  尽可能的使用 varchar/nvarchar 代替 char/nchar，可变长字段存储空间小，可以节省存储空间，搜索效率更高。

7.  除聚合函数用到HAVING外，其他地方尽量用where字句替换HAVING字句。

8.  尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。

9.  in 和 not in 也要慎用，否则会导致全表扫描。

10. 考虑是否组建「联合索引，如果组建「联合索引，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」。

11. 通过explain命令来查看SQL的执行计划，看看自己写的SQL是否走了索引，走了什么索引。

    <https://blog.csdn.net/weixin_39680135/article/details/81084324>

12. 在开启事务后,在事务内尽可能只操作数据库，并有意识地减少锁的持有时间(比如在事务内需要插入&&修改数据,那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放)。

13. 优化 insert 语句: 批量列插入数据要比单个列插入数据效率高。

14. 尽量避免子查询, 可以将子查询优化为 join 多表连接查询。

15. 使用join查询时，应该确认两个表中 Join 的字段是被建过索引的。被用来 Join 的字段，还应该是相同的类型的。

16. 多表连接的字段上需要建立索引，这样可以极大提高表连接的效率。

17. 当只要一行数据时使用 LIMIT 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。例如：查询用户表中是否有北京的用户。

18. 拆分大的插入删除语句，这两个操作可能会导致锁表，如果网站有高访问量，长时间锁表可能会导致服务挂机。可以使用LIMIT分批次删除。

### Mysql引擎

*   **InnoDB**：目前 MySQL 的**默认存储引擎**，自 MySQL 5.5 起成为默认选项。最初由第三方公司（Innobase Oy）开发，后被 Oracle 收购并集成到 MySQL 中，现在是 MySQL 官方支持的核心引擎。
*   **MyISAM**：MySQL 早期的默认引擎，由 MySQL 团队自主开发，因不支持事务和行锁，现在已逐渐被 InnoDB 取代。
*   **其他引擎**：如 MEMORY（内存引擎，数据存于内存）、CSV（以 CSV 格式存储数据）、Archive（用于归档数据）等，均为 MySQL 官方提供的内置存储引擎，用于特定场景。

#### 两种代表性引擎的核心差异

| 特性   | InnoDB           | MyISAM          |
| ---- | ---------------- | --------------- |
| 事务支持 | 支持（ACID 特性）      | 不支持             |
| 锁机制  | 行级锁（适合高并发）       | 表级锁（并发性能差）      |
| 崩溃恢复 | 支持（通过 redo log）  | 不支持（易丢失数据）      |
| 索引类型 | 聚簇索引（主键与数据存储在一起） | 非聚簇索引（索引与数据分离）  |
| 外键支持 | 支持               | 不支持             |
| 读写性能 | 写操作优（事务保障）       | 读操作优（无事务开销）     |
| 适用场景 | 电商、金融等核心业务       | 日志、报表等只读 / 少写场景 |

MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要 update 一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。InnoDB支持“行锁” ，于是在写操作比较多的时候，会更优秀。而且他还支持事务。

### 索引

> <https://www.cnblogs.com/fengqiang626/archive/2019/09/04/11459434.html>

数据库索引就是为了提高表的搜索效率而对某些字段中的值建立的目录 ，索引的数据结构用到了**B+树**。

**目的**：加快数据查找速度，提高数据库的性能。

数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为**聚簇索引**和**非聚簇索引**两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。

#### 索引的分类

1.  **普通索引**：最基本的索引，它没有任何限制。
2.  **唯一索引**：与普通索引类似，不同的就是索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<font color="lighblue">一个表可以有多个唯一索引</font>。
3.  **主键索引**：它是一种特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用 primary key 来约束。数据列不允许重复，不允许为NULL，一个表只能有一个主键。
4.  **联合索引**：多个字段上建立的索引，能够加速复合查询条件的检索。
5.  **全文索引**：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。

**优点**：

*   第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
*   第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
*   第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
*   第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
*   第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点**：

*   第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
*   第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
*   第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### MySQL索引类型

normal：表示普通索引

unique：表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique

full textl: 表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。

#### 索引七大原则

1．选择唯一性索引
2．为经常需要排序、分组和联合操作的字段建立索引
3．为常作为查询条件的字段建立索引，适合索引的列是出现在where子句中的列，或者连接子句中指定的列
4．限制索引的数目
5．使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
6．尽量使用前缀来索引
7．删除不再使用或者很少使用的索引
8．不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可

#### 创建索引的原则

*   最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
*   较频繁作为查询条件的字段才去创建索引
*   更新频繁字段不适合创建索引
*   若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
*   尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
*   定义有外键的数据列一定要建立索引。
*   对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
*   对于定义为text、image和bit的数据类型的列不要建立索引。

**索引可以是单列索引，也可以是多列索引**

（1）单列索引就是常用的一个列字段的索引，常见的索引。
（2）多列索引就是含有多个列字段的索引

**注意**：多列索引只有在where条件中含有索引中的首列字段时才有效

#### 索引查询失效的情况

1.  like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。
2.  or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。
3.  组合索引，不是使用第一列索引，索引失效。
4.  在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。
5.  对索引字段进行计算操作、字段上使用函数。
6.  当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。

**索引失效分析工具**：

可以使用**explain命令**加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。

```sql
explain select * from `order` where code='002';
```

#### b+树性质

**1.索引字段要尽量的小**：IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数。所以我们需要将树建的越低越好，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，因为id是个数字，占用空间最少啊。

**2.索引的最左匹配特性**：简单来说就是你的数据来了以后，从数据块的左边开始匹配，再匹配右边的。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了，这个是非常重要的性质，即索引的最左匹配特性。

索引是有个最左匹配的原则的，所以建联合索引的时候，将**区分度高的放在最左边**，依次排下来，范围查询的条件尽可能的往后边放。在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。先匹配最左边的，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找

### 增加索引如何避免锁表

#### 在线 DDL

MySQL 5.6 及以上版本的 InnoDB 引擎支持在线 DDL，大部分索引操作可以在 “几乎不锁表” 或 “短时间锁表” 的情况下完成。其核心原理是：通过创建临时索引文件、增量同步数据变更，避免全表复制期间的长时锁表。

#### 1. 关键参数：指定算法和锁级别

执行`ALTER TABLE`时，通过`ALGORITHM`和`LOCK`子句控制 DDL 行为，避免长时间锁表：

```sql
ALTER TABLE 表名 ADD INDEX 索引名(字段名) 
ALGORITHM=INPLACE  -- 指定算法
LOCK=NONE;         -- 指定锁级别
-- 示例
ALTER TABLE resource_files ADD INDEX idx_creator_id (creator_id)
ALGORITHM=INPLACE
LOCK=NONE;
```

**ALGORITHM（算法选择）**：

* INPLACE（推荐）：在原表上直接操作，不需要复制全表数据，仅在开始和结束阶段短暂锁表（适用于添加 / 删除二级索引）。
* COPY：通过复制全表数据到临时表实现，全程锁表（不推荐，仅用于不支持 INPLACE 的操作）。
* DEFAULT：由 MySQL 自动选择算法（可能选 COPY，建议显式指定 INPLACE）。

**LOCK（锁级别控制）**：

* NONE（推荐）：允许 DDL 期间读写表（几乎无锁），适用于添加二级索引等安全操作。
* SHARED：允许读但阻塞写，适用于对写不敏感的场景。
* EXCLUSIVE：读写全阻塞（等同于不指定，会导致长时锁表，避免使用）。

#### 2.支持 “在线” 的索引操作

并非所有索引修改都支持ALGORITHM=INPLACE和LOCK=NONE，以下是安全操作：

* 添加二级索引（最常用）：完全支持INPLACE + LOCK=NONE，几乎不阻塞业务。
* 删除二级索引：支持INPLACE + LOCK=NONE，操作快速（仅删除索引元数据）。
* 添加 / 删除主键：需要ALGORITHM=INPLACE，但会短暂锁表（因主键是聚簇索引，涉及数据重组织）。

#### 不支持在线操作的场景（需谨慎）：

* 修改字段类型、长度（可能导致全表重组织）。
* 添加 / 删除唯一索引（可能需要校验数据唯一性，锁表时间较长）。

#### 使用第三方工具：pt-online-schema-change（大表首选）

对于超大规模表（如亿级数据），即使在线 DDL 也可能有短暂锁表或性能波动，此时推荐使用 Percona Toolkit 的pt-online-schema-change工具。其核心逻辑是通过 “影子表” 异步同步数据，全程不锁原表。

**1.工作原理**

1. 创建一个与原表结构相同的 “影子表”（_原表名_new）。
2. 在影子表上执行索引修改（因表为空，瞬间完成）。
3. 创建触发器，实时同步原表的新增 / 修改 / 删除数据到影子表。
4. 批量复制原表历史数据到影子表（可控制速率，避免冲击业务）。
5. 数据同步完成后，原子性地将原表名切换为影子表（RENAME TABLE，毫秒级）。
6. 删除原表和触发器，完成操作。

**2. 使用示例（添加索引）**

```bash
# 安装Percona Toolkit（需先安装依赖）
yum install percona-toolkit -y

# 执行索引修改（--alter指定添加索引，--user/--password指定数据库账号）
pt-online-schema-change \
  --alter "ADD INDEX idx_name (name)" \
  D=数据库名,t=表名 \
  --user=root --password=密码 \
  --execute
```

**优势：**

* 全程不锁原表，读写业务不受影响。
* 支持限速（--max-lag），避免同步数据时占用过多资源。
* 可中断恢复（支持断点续传）。

**总结**

* 中小表（百万级）：直接使用ALTER TABLE ... ALGORITHM=INPLACE LOCK=NONE，简单高效。
* 大表（千万 / 亿级）：优先用pt-online-schema-change，全程无锁，安全性高。
* 核心原则：通过 “不锁表” 或 “短锁表” 的方式，避免修改索引时阻塞业务读写，同时做好备份和监控。

### 三种数据一致性问题

#### 脏读、不可重复读、幻读

**脏读**：一个事务读取到另一个事务未提交的修改数据。

**不可重复读**：同一事务内，多次读取同一数据时，结果不一致（因其他事务对数据做了已提交的修改）。

**幻读**：同一事务内，多次执行相同查询时，结果集的行数不一致（因其他事务新增 / 删除了符合条件的数据）。

一般来说，锁可以防止脏读、不可重复读和幻读。

#### 事务隔离四种级别

1.  读未提交(Read Uncommitted)  允许脏读。
2.  读已提交(Read Committed)  防止脏读，最常用的隔离级别，并且是大多数数据库的默认隔离级别。
3.  可重复读(Repeated Read)  可以防止脏读和不可重复读，MySQL 默认级别。
4.  可串行化(Serializable)  可以防止脏读，不可重复读取和幻读，(事务串行化)会降低数据库的效率。

选用什么隔离级别，主要看应用场景，隔离级别越低，事务并发能力越高。MySQL默认的隔离级别是**可重复读**

*   脏读：事务修改数据时会对记录加**排他锁**，其他事务无法读取该数据，直到锁释放。
*   不可重复读：**MVCC**（多版本并发控制）
*   幻读问题：InnoDB 引入了间隙锁和 next-key Lock（临键锁）机制来解决幻读问题。间隙锁，它的主要功能是锁定一段范围内的索引记录。**临键锁**是行锁和间隙锁的组合。

### 数据库锁

#### 1.行锁和表锁

1.主要是针对锁粒度划分的，一般分为：行锁、表锁、库锁

行锁：访问数据库的时候，锁定整个行数据，防止并发错误。

表锁：访问数据库的时候，锁定整个表数据，防止并发错误。

2.行锁 和 表锁 的区别：

表锁： 开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

行锁： 开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

#### 2.悲观锁和乐观锁

（1）悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

（2）乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

### 锁表

解决死锁的方案

第一种：

1.查询是否锁表

```sql
show OPEN TABLES where In_use > 0;
```

2.查询进程(如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程)

```sql
show processlist
```

3.杀死进程id(就是上面命令的id列)

kill id

第二种：

1.查看下在锁的事务

```sql
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```

2.杀死进程id(就是上面命令的trx\_mysql\_thread\_id列)

kill 线程ID

### MVCC多版本并发控制

MVCC（多版本并发控制）是数据库实现并发访问的一种机制，通过为数据记录保存多个版本，实现读写分离，避免读写操作相互阻塞。通过维护数据的历史版本快照，允许事务读取特定时间点的数据状态，减少锁竞争并提升性能。其核心原理是在事务操作时保留数据旧版本，结合版本链与可见性规则判断数据可访问性，适用于读已提交和可重复读隔离级别 。

可将MVCC看成行级别锁的一种妥协，它在许多情况下避免了使用锁，同时可以提供更小的开销。根据实现的不同，它可以允许非阻塞式读，在写操作进行时只锁定必要的记录。

**解决的问题**：

*   传统锁机制中，读会阻塞写，写也会阻塞读，导致并发性能低下；
*   解决了事务隔离级别的实现难题（如可重复读、读已提交）；
*   减少了锁竞争，降低了死锁概率。

**MVCC 和锁机制的区别是什么？**

**答案**：

| 维度    | MVCC           | 锁机制             |
| ----- | -------------- | --------------- |
| 核心思想  | 通过多版本实现读写分离    | 通过加锁限制并发操作      |
| 阻塞情况  | 读不阻塞写，写不阻塞读    | 读可能阻塞写（或反之）     |
| 适用场景  | 读多写少的高并发场景     | 对数据一致性要求极高的场景   |
| 实现复杂度 | 较复杂（需维护版本和可见性） | 相对简单（基于锁的获取与释放） |

**总结**：MVCC 是 “无锁” 并发控制的典型实现，而锁机制是 “有锁” 控制，两者常结合使用（如 InnoDB 中 MVCC 配合行锁）。

**MySQL 的 InnoDB 如何实现 MVCC？**

**答案**：
InnoDB 通过以下核心组件实现 MVCC：

1.  **隐藏字段**：
    *   `DB_TRX_ID`：记录最后修改该记录的事务 ID；
    *   `DB_ROLL_PTR`：回滚指针，指向该记录的上一个版本（存储在 undo 日志中）；
    *   `DB_ROW_ID`：自增 ID（当表无主键时生成）。
2.  **Undo 日志**：
    保存数据的历史版本，当事务修改记录时，旧版本被写入 undo 日志，通过`DB_ROLL_PTR`串联成版本链。
3.  **Read View（读视图）**：
    事务启动时生成的快照，包含当前活跃事务的 ID 列表，用于判断数据版本的可见性：
    *   若数据版本的`DB_TRX_ID`小于当前事务 ID 且不在活跃列表中，说明该版本已提交，可见；
    *   反之不可见，需通过`DB_ROLL_PTR`读取更早版本。

**为什么说 MVCC 是 “非阻塞读”？**

因为 MVCC 通过读取数据的历史版本（快照）实现读操作，而不是直接访问当前正在被修改的记录。
写操作会生成新的版本，不影响旧版本的读取；
读操作无需加锁，也不会阻塞写操作，因此称为 “非阻塞读”。

### 数据库主从+读写分离

**优先选 ProxySQL 的情况**

*   核心需求是读写分离、负载均衡、连接池集中管理；
*   应用是多语言开发（非纯 Java）；
*   数据库以 MySQL/MariaDB 为主，且无需分库分表。

**优先选 ShardingSphere-JDBC 的情况**

*   核心需求是分库分表（数据量超千万 / 亿级）；
*   需要处理跨库分布式事务；
*   应用是 Java 开发，且对性能损耗敏感。

### Explain性能分析工具

![](https://share.note.youdao.com/yws/api/personal/file/WEBca3400a11d3a3c4f008eb1a5bc7e5982?method=download\&shareKey=b43640da0e4c41130ea5c4e1a4be4448)

#### 1.type列性能排序（从高到低）

system(系统表) > const(通过主键或唯一索引一次找到) > eq\_ref(唯一索引关联查询) > ref(非唯一索引查找) > range(索引范围扫描) > index(全索引扫描) > ALL(全表扫描)

*   避免 `ALL`（全表扫描），尤其是大表。
*   尽量达到 `range`（索引范围扫描）或更高。

#### 2.key 和 Extra 列判断索引是否生效

*   key 列：显示实际使用的索引，若为 `NULL` 则未使用索引。
*   Extra 列：
    *   Using index：覆盖索引（查询列全在索引中，无需回表）。
    *   Using where：在存储引擎返回数据后，服务层过滤（可能索引未完全覆盖）。
    *   Using filesort：需额外排序（通常因 ORDER BY 未使用索引）。
    *   Using temporary：使用临时表（通常因 GROUP BY 或 DISTINCT 未优化）。

#### 3.预估扫描行数（rows 列）—— 判断查询复杂度

rows 是 MySQL 预估需要检查的行数，值越大查询越慢。建议使用高区分度列作为索引。

#### 4.连接查询优化（id 和 select\_type 列）—— 多表查询的关键

*   `id` 列
    *   相同：执行顺序从上到下。
    *   不同：值越大越先执行。

*   `select_type` 列
    *   `DERIVED`：FROM 子句中的子查询（需优化为 JOIN 或临时表）。
    *   `SUBQUERY`：非相关子查询（可能被优化为 JOIN）。

#### 5.覆盖索引（Extra=Using index）—— 性能优化的终极技巧

覆盖索引查询列全部包含在索引中，无需回表查询数据行，查询速度快。

*   Using index：使用覆盖索引
*   Using where：使用 WHERE 过滤
*   Using temporary：使用临时表（通常需要优化）
*   Using filesort：使用文件排序（通常需要优化）
*   Using join buffer：使用连接缓存

可为常用查询条件 + 返回列创建复合索引。

### PROCEDURE ANALYSE() 优化建议

PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用。

```sql
SELECT * FROM lesson PROCEDURE ANALYSE();
```

