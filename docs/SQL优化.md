# SQL优化

1. 在经常需要进行检索的字段上创建索引。

2. 一个表的索引数最好不要超过6个，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。

3. 尽量将多条SQL语句压缩到一句SQL中，避免过多的执行SQL语句。

4. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

5. 尽可能的使用 varchar/nvarchar 代替 char/nchar，可变长字段存储空间小，可以节省存储空间，搜索效率更高。

6. 除聚合函数用到HAVING外，其他地方尽量用where字句替换HAVING字句。

7. 尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。

8. in 和 not in 也要慎用，否则会导致全表扫描。

9. 考虑是否组建「联合索引，如果组建「联合索引，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」。

10. 通过explain命令来查看SQL的执行计划，看看自己写的SQL是否走了索引，走了什么索引。

    https://blog.csdn.net/weixin_39680135/article/details/81084324

11. 在开启事务后,在事务内尽可能只操作数据库，并有意识地减少锁的持有时间(比如在事务内需要插入&&修改数据,那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放)。

### 索引

> https://www.cnblogs.com/fengqiang626/archive/2019/09/04/11459434.html

数据库索引就是为了提高表的搜索效率而对某些字段中的值建立的目录 ，索引的数据结构用到了**B+树**。

**目的**：加快检索表中数据

数据库索引好比是一本书前面的目录，能加快数据库的查询速度。索引分为**聚簇索引**和**非聚簇索引**两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。

**唯一索引**：唯一索引是不允许其中任何两行具有相同索引值的索引。数据列不允许重复，允许为NULL值，<font color="lighblue">一个表可以有多个唯一索引</font>。

**主键索引**：数据库表经常有一列或多列组合，其值唯一标识表中的每一行。数据列不允许重复，不允许为NULL，一个表只能有一个主键。

**聚集索引**：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。<font color="lighblue">一个表只能包含一个聚集索引</font>。

**优点**：

- 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
- 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
- 第五，通过使用[索引](https://baike.baidu.com/item/索引)，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点**：

- 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
- 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
- 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### MySQL索引类型

normal：表示普通索引

unique：表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique

full textl: 表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。

spatial

#### 索引七大原则

1．选择唯一性索引
2．为经常需要排序、分组和联合操作的字段建立索引
3．为常作为查询条件的字段建立索引，适合索引的列是出现在where子句中的列，或者连接子句中指定的列 
4．限制索引的数目
5．使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间 
6．尽量使用前缀来索引
7．删除不再使用或者很少使用的索引
8．不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可

#### 创建索引的原则

- 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 
- 较频繁作为查询条件的字段才去创建索引 
- 更新频繁字段不适合创建索引 
- 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低) 
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 
- 定义有外键的数据列一定要建立索引。 
- 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。 
- 对于定义为text、image和bit的数据类型的列不要建立索引。 

**索引可以是单列索引，也可以是多列索引**

（1）单列索引就是常用的一个列字段的索引，常见的索引。 
（2）多列索引就是含有多个列字段的索引 

**注意**：多列索引只有在where条件中含有索引中的首列字段时才有效 

#### b+树性质

**1.索引字段要尽量的小**：IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数。所以我们需要将树建的越低越好，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，因为id是个数字，占用空间最少啊。

**2.索引的最左匹配特性**：简单来说就是你的数据来了以后，从数据块的左边开始匹配，再匹配右边的。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了，这个是非常重要的性质，即索引的最左匹配特性。

索引是有个最左匹配的原则的，所以建联合索引的时候，将**区分度高的放在最左边**，依次排下来，范围查询的条件尽可能的往后边放。在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 

### 脏读、幻读、不可重复读

**脏读:**举个例子,如果你正在读数据库内容,而我现在修改了数据库内容还没有提交,接着我修改后的内容没有提交的情况下被你读到了,就叫脏读。

**幻读**:举个例子,比如你正在读数据库内容,而我insert数据库后提交了,你又读了一次数据库内容,这时你看到内容出现了多一条数据,这叫幻读。

**不可重复读:**举个例子,比如你正在读数据库内容,而我update数据库后提交了,你又读了一次数据库内容,这时出现两个内容不同的结果,这叫不可重复读。

一般来说，锁可以防止脏读、不可重复读和幻觉读。

 事务隔离五种级别：
        TRANSACTION_NONE  不使用事务。
        TRANSACTION_READ_UNCOMMITTED  允许脏读。
        TRANSACTION_READ_COMMITTED  防止脏读，最常用的隔离级别,并且是大多数数据库的默认隔离级别
        TRANSACTION_REPEATABLE_READ  可以防止脏读和不可重复读，
        TRANSACTION_SERIALIZABLE  可以防止脏读，不可重复读取和幻读，（事务串行化）会降低数据库的效率

- 脏读：修改时加排他锁，直到事务提交后才释放，读取时加共享锁，读取完释放事务1读取数据时加上共享锁后（这 样在事务1读取数据的过程中，其他事务就不会修改该数据），不允许任何事物操作该数据，只能读取，之后1如果有更新操作，那么会转换为排他锁，其他事务更 无权参与进来读写，这样就防止了脏读问题。
  但是当事务1读取数据过程中，有可能其他事务也读取了该数据，读取完毕后共享锁释放，此时事务1修改数据，修改 完毕提交事务，其他事务再次读取数据时候发现数据不一致，就会出现不可重复读问题，所以这样不能够避免不可重复读问题。
- 不可重复读：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题
- 幻读问题：采用的是范围锁RangeS RangeS_S模式，锁定检索范围为只读，这样就避免了幻影读问题，在这里有个描述范围锁的文章。

选用什么隔离级别，主要看应用场景，隔离级别越低，事务并发能力越高。MySQL默认的隔离级别是Repeatable read

### 锁表

解决死锁的方案

第一种：

1.查询是否锁表

```sql
show OPEN TABLES where In_use > 0;
```

2.查询进程(如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程)

```sql
show processlist
```

3.杀死进程id(就是上面命令的id列)

kill id

第二种：

1.查看下在锁的事务

```sql
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```

2.杀死进程id(就是上面命令的trx_mysql_thread_id列)

kill 线程ID

